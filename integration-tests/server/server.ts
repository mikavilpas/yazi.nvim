import { Server } from "socket.io"
import { TerminalApplication } from "./TerminalApplication.ts"

import express from "express"
import assert from "node:assert"
import { createServer } from "node:http"
import path from "node:path"
import * as url from "url"
import type { StartAppMessageArguments } from "../client/startAppGlobalType"

export type StdinMessage = "stdin"
export type StdoutMessage = "stdout"
export type StartAppMessage = "startApp"

const expressApp = express()
const server = createServer(expressApp)
const connections: Map<string, TerminalApplication> = new Map()
const __dirname = url.fileURLToPath(new URL(".", import.meta.url))

const io = new Server(server, {
  cors: {
    origin: (requestOrigin, callback): void => {
      if (
        requestOrigin == "http://localhost:5173" ||
        requestOrigin == "http://localhost:5174"
      ) {
        callback(null, requestOrigin)
      } else {
        callback(new Error("Not allowed by CORS"))
      }
    },
  },
})

io.on("connection", function connection(socket) {
  // TODO this should be generated by the browser to make it reliable
  // or connection state recovery could be used
  // https://socket.io/docs/v4/connection-state-recovery
  const peerId = socket.id

  socket.on(
    "startApp" satisfies StartAppMessage,
    function (args: StartAppMessageArguments) {
      const testDirectory = path.join(__dirname, "..", "test-environment/")
      const app = TerminalApplication.start({
        command: args.command,
        args: args.args,

        cwd: testDirectory,
        env: process.env,

        onStdoutOrStderr(data: string) {
          void socket
            .timeout(500)
            .emitWithAck("stdout" satisfies StdoutMessage, data)
            .catch((e: unknown) => {
              app.logger.debug(
                `I sent stdout to the client, but did not get an acknowledgement back in 500ms ðŸ¤”: `,
                e,
              )
            })
        },
      } satisfies StartAppMessageArguments & Record<string, unknown>)
      connections.set(peerId, app)

      socket.on("disconnect", async (_reason) => {
        await app.waitUntilCleanedUp()
      })

      void app.finishedPromise.promise.then(() => {
        app.logger.info(`TerminalApplication ${peerId} finished`)
        connections.delete(peerId)
      })

      socket.on("stdin" satisfies StdinMessage, function (data) {
        assert(typeof data === "string", "stdin message must be a string")
        app.write(data)
      })
    },
  )
})

process.on("SIGINT", () => {
  console.log("Received SIGINT. Cleaning up...")
  async function cleanup() {
    for (const app of connections.values()) {
      await app.waitUntilCleanedUp()
    }
    process.exit(0)
  }

  void cleanup()
})

server.listen(3000, () => {
  console.log("server running at http://localhost:3000")
})
